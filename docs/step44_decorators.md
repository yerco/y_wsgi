# Decorator
In this section, we’ll walk through a practical implementation of the Decorator pattern in the Y-WSGI framework.
The Decorator pattern allows you to dynamically add behavior to objects without modifying their code. 
This is particularly useful in web frameworks for applying cross-cutting concerns like logging, 
security checks, or custom headers.

## The Base View Class
The `View` class serves as the base class for handling HTTP requests. It has a method map that routes
HTTP methods (GET, POST, etc.) to their corresponding handler methods (get, post, etc.).

Here’s a simplified breakdown:
- `__call__` Method: When an instance of View or any subclass is called, it executes the execute method, 
  which determines which HTTP method was used and calls the appropriate handler.
- `get`, `post`, etc.: These are placeholder methods that can be overridden by subclasses to provide 
  custom behavior for each HTTP method.

## Example View: AnotherView
The `AnotherView` class is a subclass of View that specifically handles GET requests. 
When the GET request is received, it uses the `HTTPResponseBuilder to create a simple text/plain response.
```python
from typing import Dict, Any
from src.core.view import View
from src.decorators.log_request_decorator import LogRequestDecorator
from src.decorators.custom_headers_decorator import CustomHeadersDecorator
from src.http.http_response_builder import HTTPResponseBuilder

# Custom view class that handles GET requests
class AnotherView(View):
    def get(self, request_context, params: Dict[str, Any] = None):
        response_builder = HTTPResponseBuilder()
        response = (response_builder
                    .set_status(200)
                    .set_body(b"Another view")
                    .set_header("Content-type", "text/plain")
                    .build())
        return response

# Decorate the view with additional behavior
another_view = AnotherView()
decorated_view = LogRequestDecorator(CustomHeadersDecorator(another_view))

# Register the route in the module
def register_routes(module):
    @module.route('/another', methods=['GET'])
    def another_view_handler(request_context, **kwargs):
        return decorated_view(request_context, **kwargs)
```

### Implementing the Decorators
`ViewDecorator`: This is the base class for all decorators. It delegates the handling of the request to the decorated view.
```python
from src.core.view import View

class ViewDecorator(View):
    def __init__(self, view: View):
        super().__init__()
        self._view = view

    def execute(self, request_context: RequestContext, **params: Any) -> Response:
        return self._view.execute(request_context, **params)
```

This decorator logs each request before passing it to the wrapped view.
```python
class LogRequestDecorator(ViewDecorator):
    def execute(self, request_context: RequestContext, **params) -> Response:
        print(f"Logging request: {request_context.path}")
        return super().execute(request_context, **params)
```

This decorator adds custom headers to the response after it is generated by the wrapped view.
```python
class CustomHeadersDecorator(ViewDecorator):
    def execute(self, request_context: RequestContext, **params) -> Response:
        response = super().execute(request_context, **params)
        response.set_header("X-Custom-Header", "A Custom Value")
        return response
```

## Bonus track `as_view` (django-like)
The primary purpose of the `as_view()` method is to provide flexibility and reusability for views. By using `as_view()`,
developers can define views as classes, encapsulate request-handling logic, and easily reuse these views 
across different routes.

### How It Works
1. Class Method: `as_view()` is a class method, meaning it can be called directly on the class without needing to
   create an instance first.
2. Instance Creation: When `as_view()` is called, it creates an instance of the view class. This instance is
   then used to handle the incoming request.
3. Callable Function: The method returns a function that can be used as a route handler. 
   This function takes `request_context` and `**params` as arguments and delegates the request handling 
   to the created instance.
4. Method Dispatching: Inside this function, the appropriate HTTP method handler (get, post, etc.)
   is called based on the request’s HTTP method. If the method is not allowed, a 405 Method Not Allowed 
   response is returned.

Example
```python
class ExampleAsView(View):
    def get(self, request_context, params: Dict[str, Any] = None):
        response_builder = HTTPResponseBuilder()
        response = (response_builder
                    .set_status(200)
                    .set_body(b"Hello from Example view")
                    .set_header("Content-type", "text/plain")
                    .build())
        return response


example_as_view = ExampleAsView()


def register_routes(module):
    @module.route('/example-as-view', methods=['GET'])
    def example_as_view_handler(request_context, **kwargs):
        return example_as_view(request_context, **kwargs)
```

Benefits
- Reusability: Views can be reused in different contexts without rewriting the logic.
- Encapsulation: Request-handling logic is neatly encapsulated within a class, promoting better 
  organization and maintainability.
- Consistency: Provides a consistent approach to defining and using views across the framework.
